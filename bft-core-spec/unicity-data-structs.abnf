; Unicity Protocol Data Structures (ABNF)

; ============================================================================
; 1. BFT CORE (shared data structures)

  UC = IR TechRecordHash ShardTreeCertificate UnicityTreeCertificate UnicitySeal  ;~$UC = (IR, h_t, C^\mathsf{shard}, C^\mathsf{uni}, C^\mathsf{r})$
  IR = RoundNumber Epoch PreviousHash Hash Time  ;~$IR = (n, e, h', h, t)$
  ShardTreeCertificate = ShardIdentifier *SiblingHash  ;~$C^\mathsf{shard} = (\sigma;h^s_1, \ldots, h^s_{|\sigma|})$
  UnicityTreeCertificate = PartitionIdentifier PartitionDescriptionHash *HashStep
  HashStep = PartitionIdentifier SiblingHash  ;~$C^\mathsf{uni} = (\beta, \mathsf{dhash}; (\beta_2, h_2), \ldots, (\beta_\ell, h_\ell)))$

  UnicitySeal = Version NetworkIdentifier RootPartitionRoundNumber Epoch Timestamp PreviousHash Hash *Signatures  ;~$C^\mathsf{r} = (\alpha, n_r, t_r, r_-, r; s)$
                      ;~where |Signatures| = quorumThreshold > 2f

; --- Statistical and Technical Records ---
  StatisticalRecord = NumRounds SumRoundSize SumStateSize MaxRoundSize MaxStateSize ;~$\mathsf{SR}=(n_e, \overline{\ell}_B, \overline{\ell}_S, \hat{\ell}_B, \hat{\ell}_S)$
  TechRecord = Round Epoch LeaderID SRHash  ;~$\mathsf{TE}=(n_r, e_r, \nu_\ell, h_\mathsf{sr})$

  ShardInfo = Round PreviousHash PrevStatisticalRecord StatisticalRecord *ValidatorIdentifier LeaderIdentifier PrevUC ;~$(n,h_-, \mathsf{SR}_-, \mathsf{SR}, \mathcal{V}, \nu_\ell, UC_-)$

  ; Evolving trust base:
  UnicityTrustBase = Version *UnicityTrustBaseEntry
  UnicityTrustBaseEntry = NetworkIdentifier Epoch *(NodeID Pubkey Stake) QuorumThreshold StateHash ChangeRecordHash PreviousEntryHash *Signatures

; ============================================================================
; BFT CORE (internal data structures)

; --- Internal Consensus Structures ---
  LedgerCommitInfo = UnicitySeal
  QC = VoteInfo LedgerCommitInfo *Signatures

  VoteInfo = RoundInfo
  RoundInfo = RoundNumber Epoch Timestamp ParentRoundNumber CurrentRootHash

; --- BFT Core Messages ---
  VoteMsg = VoteInfo LedgerCommitInfo HighQC Author Signature

  ProposalMsg = BlockData [LastRoundTc] Signature
  BlockData   = Author Round Epoch Timestamp Payload AncestorQC
  Payload     = *IRChangeReq | RCEpochChangeReq
  IRChangeReq = PartitionIdentifier CertReason *CR [EpochChangeJustification] SenderSignature
              ; presence of justification ==> epoch++
  RPEpochChangeReq = Epoch *(NodeID Pubkey Stake) QuorumThreshold StateHash ChangeRecordHash PreviousEntryHash SenderSignature [ChangeRecord]

  TimeoutMsg = Timeout Author Signature [LastTC]
      ;~If HighQC is not from prev. round then there must be TC of prev,
      ;~justifying the incremented round number
  Timeout = Epoch Round HighQC   ;~HighQC - highest known Quorum Certificate to the validator
  TC = Timeout *Signatures ;~2f+1 Signatures  ;~TC - Timeout Certificate

  CertReason    = 'quorum' | 'quorum-not-possible' | 't2-timeout'  ;~flags in appropriate encoding

; --- Recovery Messages ---
  GetStateMsg = NodeId   ; id of the validator requesting the state
  StateMsg = *UC CommittedHead BlockNode UnicityTrustBaseEntry
  CommittedHead = BlockNode = RecoveryBlock
  RecoveryBlock = BlockData *InputData QC CommitQC
  InputData = PartitionIdentifier Shard IR Sdrh

; ============================================================================
; 3. BFT CORE (protocols)

  CR = NetworkIdentifier PartitionIdentifier Shard NodeIdentifier IR BatchSize StateSize Signature [ConsistencyProof]
  ; Certification Request $CR = \langle \alpha, \beta, \sigma, \nu; \mathcal{IR},\ell_B,\ell_S; s; [\pi_{CP}]\rangle$
  ; ConsistencyProof is optional - can be hash-based or ZK-compressed
  ; Hash-based: full proof (B, Pi) for BFT Core to verify state transition
  ; ZK-compressed: SNARK/STARK with public params matching IR
  ;  if prevStateTreeHash is already 'extended' with UC then return latest UC immediately.
  ;  otherwise validation and cert. generation continues, cert is returned once available.
  ;  Returned UC can be repeated cert for prevStateTreeHash which triggers next attempt using different leader
  ;  a validator can have multiple pending requests extending the same hash; latest one is identified using IR.n

  CReS = NetworkIdentifier PartitionIdentifier ShardIdentifier UC TechRecord [UnicityTrustBaseEntry]
        ;~Certification~Response

  ; Subscription - Subscribe to CReS message feed in order to obtain the latest UC for synchronization
  SubscriptionMsg = NetworkIdentifier PartitionIdentifier Shard NodeIdentifier signature
        ; this request provides or updates validator connection parameters at
        ; transport layer so that Root can return CReS messages

  ; Trust Base Distribution protocol
  GetTrustBaseMsg = NetworkIdentifier EpochStart [EpochEnd]
  TrustBaseResponse = *UnicityTrustBaseEntry

; ============================================================================
; 4. AGGREGATION LAYER

  StateIdentifier = Hash  ;~$\mathsf{sid} = H(\mathsf{pk}, h_{\mathsf{st}})$
  LeafData = TransactionHash    ;~value of key-value store
  SMTLeaf = StateIdentifier LeafData  ;~$L = (\mathsf{sid}, h_{\mathsf{tx}})$

  InclusionCertificate = *InclusionStep  ;~$C^\mathsf{inc} = \langle (p_1, d_1), (p_2, d_2), \ldots, (p_n, d_n) \rangle$
  InclusionStep = PathSegment (LeafData | SiblingHash)
      ;~First step contains LeafData, subsequent steps contain sibling hashes
      ;~Concatenated path segments equal the full StateIdentifier

  ConsistencyProof = Batch ProofSiblings | ZKProof
      ;~$\pi_{\mathsf{CP}}$ - proves correct SMT manipulation (append-only)
      ;~Hash-based: batch and sibling hashes for verification
      ;~ZK-compressed: SNARK/STARK proof with public params

  Batch = *SMTLeaf  ;~Batch of new SMT leaves
  ProofSiblings = *DepthLayer  ;~Sibling hashes organized by tree depth
  DepthLayer = *SiblingHashPair
  SiblingHashPair = StateIdentifier Hash
  ZKProof = Bytes  ;~Opaque ZK proof (SNARK/STARK)

  InclusionProof = InclusionCertificate UC  ;~$\pi^\mathsf{inc} = (C^\mathsf{inc}, UC)$
      ;~Complete proof from SMT leaf through UC to trust base
      ;~Proves that a StateID EXISTS in the SMT
      ;~SMT Leaf L = (sid, htx) can be extracted from InclusionCertificate:
      ;~  sid = concatenation of all path segments p1 || p2 || ... || pn
      ;~  htx = d1 (leaf data from first pair)

  NonInclusionProof = InclusionCertificate UC  ;~$\pi^\mathsf{exc} = (C^\mathsf{inc}, UC)$
      ;~Exclusion proof - proves that a StateID does NOT exist in the SMT
      ;~Uses same structure as InclusionProof but with different validation
      ;~Valid for queried sid if:
      ;~  1. VerifyInclusionProof returns TRUE
      ;~  2. p1 is a prefix of sid (queried StateID)
      ;~  3. d1 = empty (position is unoccupied)

; ============================================================================
; 5. TOKEN / EXECUTION LAYER

  TokenState = OwnerPublicKey AuxiliaryData
      ;~Token state $S = (\mathsf{pk}, \mathsf{aux})$

  TransactionData = RecipientPublicKey BlindingMask RecipientAuxiliaryData [MintTransactionData]
      ;~$D = (\mathsf{pk}', x, \mathsf{aux}')$ unified for mint and transfer

  MintTransactionData = TokenId TokenType TokenData [CoinData] [MintReason]
      ;~Additional fields for mint transactions (empty for transfers)

  CoinData = CoinId Balance   ;~for fungible tokens
  CoinId = Bytes32  ;~32-byte identifier for a specific coin type

  Transaction = CurrentStateHash TransactionData
      ;~$T = (h_{\mathsf{st}}, D)$

  TransactionHash = Hash  ;~$h_{\mathsf{tx}} = H(D)$

  CertifiedTransaction = Transaction Signature TransactionHash InclusionProof
      ;~$(T, \sigma, h_{\mathsf{tx}}, \pi^\mathsf{inc})$

  UnicityServiceRequest = OwnerPublicKey CurrentStateHash TransactionHash Signature
      ;~$Q = (\mathsf{pk}, h_{\mathsf{st}}, h_{\mathsf{tx}}, \sigma)$
      ;~Submitted to aggregation layer for state transition certification

  InclusionProofRequest = StateIdentifier  ;~$\mathsf{sid} = H(\mathsf{pk}, h_{\mathsf{st}})$
      ;~Query if a StateID exists in the SMT

  InclusionProofResponse = Success [InclusionProof] [ErrorMessage]
      ;~Response when StateID exists in the SMT

  NonInclusionProofRequest = StateIdentifier  ;~$\mathsf{sid} = H(\mathsf{pk}, h_{\mathsf{st}})$
      ;~Query to prove a StateID does NOT exist in the SMT

  NonInclusionProofResponse = Success [NonInclusionProof] [ErrorMessage]
      ;~Response proving StateID does not exist in the SMT
      ;~Aggregator returns this when queried StateID is not present

  Token = Version CurrentTokenState GenesisCertifiedTransaction *CertifiedTransaction
      ;~Complete token with full provenance chain
