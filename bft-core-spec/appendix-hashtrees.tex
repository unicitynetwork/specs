\chapter{Hash Trees}\label{app:hashtrees}

\section{Plain Hash Trees}

\subsection{Function $\textsc{plain\_tree\_root}$}\label{sec:plain-tree-root}

Computes the root value of the plain hash tree with the given $n$ values in its leaves.

\textbf{Input}:
$L = \langle x_1, \ldots, x_n \rangle \in \hashtype^n$, the list of the values in the $n$ leaves of the tree

\textbf{Output}:
$r \in \hashtype\opt$, the value in the root of the tree

\textbf{Computation}:
\begin{algorithmic}
	\Function{plain\_tree\_root}{$L$}
		\If {$n = 0$} \Comment{$L = \langle \rangle$}
			\State \Return $\bot$
		\ElsIf {$n = 1$} \Comment{$L = \langle x_1 \rangle$}
			\State \Return $x_1$
		\Else
			\State $m \gets 2^{\lfloor \log_2(n-1) \rfloor}$ \Comment{Canonical tree}
			\State $L_\mathsf{left} \gets \langle x_1, \ldots, x_m \rangle$
			\State $L_\mathsf{right} \gets \langle x_{m+1}, \ldots, x_n \rangle$
			\State \Return $H(\Call{plain\_tree\_root}{L_\mathsf{left}} , \Call{plain\_tree\_root}{L_\mathsf{right}})$
		\EndIf
	\EndFunction
\end{algorithmic}

Note that $2^{\lfloor \log_2(n-1) \rfloor}$ is the value of the highest $1$-bit in the binary representation of $n - 1$, which may be the preferred way to compute $m$ in some environments. Splitting the leaves this way results in a structure that allows the root of the tree to be computed incrementally, without having all the leaves in memory at once.

\subsection{Function $\textsc{plain\_tree\_chain}$}\label{sec:plain-tree-chain}

Computes the hash chain from the $i$-th leaf to the root of the plain hash tree with the given $n$ values in its leaves.

\textbf{Input}:
\begin{enumerate}
	\item $L = \langle x_1, \ldots, x_n \rangle \in \hashtype^n$, the list of the values in the $n$ leaves of the tree
	\item $i \in \{1, \ldots, n\}$, the index of the starting leaf of the chain
\end{enumerate}

\textbf{Output}:
$C = \langle (b_1, y_1), \ldots, (b_\ell, y_\ell) \rangle \in (\bool \times \hashtype)^\ell$, where $y_j$ are the sibling hash values on the path from the $i$-th leaf to the root and $b_j$ indicate whether the corresponding $y_j$ is the right- or left-hand sibling

\textbf{Computation}:
\begin{algorithmic}
	\Function{plain\_tree\_chain}{$L; i$}
		\State \Assert $1 \le i \le n$
		\If {$n = 1$} \Comment{$L = \langle x_1 \rangle$}
			\State \Return $\langle \rangle$
		\Else
			\State $m \gets 2^{\lfloor \log_2(n-1) \rfloor}$ \Comment{Must match \textsc{plain\_tree\_root}}
			\State $L_\mathsf{left} \gets \langle x_1, \ldots, x_m \rangle$
			\State $L_\mathsf{right} \gets \langle x_{m+1}, \ldots, x_n \rangle$
			\If {$i \le m$}
				\State \Return $\Call{plain\_tree\_chain}{L_\mathsf{left}; i} \| (0, \Call{plain\_tree\_root}{L_\mathsf{right}})$
			\Else
				\State \Return $\Call{plain\_tree\_chain}{L_\mathsf{right}; i-m} \| (1, \Call{plain\_tree\_root}{L_\mathsf{left}})$
			\EndIf
		\EndIf
	\EndFunction
\end{algorithmic}

\subsection{Function $\textsc{plain\_tree\_output}$}\label{sec:plain-tree-output}

Computes the output hash of the chain $C$ on the input $x$.

\textbf{Input}:
\begin{enumerate}
	\item $C = \langle (b_1, y_1), \ldots, (b_\ell, y_\ell) \rangle \in (\bool \times \hashtype)^\ell$, where $y_j$ are the sibling hash values on the path from the $i$-th leaf to the root and $b_j$ indicate whether the corresponding $y_j$ is the right- or left-hand sibling
	\item $x \in \hashtype$, the input hash value
\end{enumerate}

\textbf{Output}:
$r \in \hashtype$, output value of the hash chain

\textbf{Computation}:
\begin{algorithmic}
	\Function{plain\_tree\_output}{$C; x$}
		\If {$\ell = 0$} \Comment{$C = \langle \rangle$}
			\State \Return $x$
		\Else
			\State \Assert $b_\ell \in \bool$
			\If {$b_\ell = 0$}
				\State \Return $H(\Call{plain\_tree\_output}{\langle (b_1, y_1), \ldots, (b_{\ell-1}, y_{\ell-1}) \rangle; x}, y_\ell)$
			\Else
				\State \Return $H(y_\ell, \Call{plain\_tree\_output}{\langle (b_1, y_1), \ldots, (b_{\ell-1}, y_{\ell-1}) \rangle; x})$
			\EndIf
		\EndIf
	\EndFunction
\end{algorithmic}

\subsection{Inclusion Proofs}

Plain hash trees can be used to provide and verify inclusion proofs. The process for this is as follows:

\begin{itemize}
	\item To commit to the contents of a list $L = \langle x_1, \ldots, x_n \rangle$:
		\begin{itemize}
			\item Compute $r \gets \Call{plain\_tree\_root}{L}$.
			\item Authenticate $r$ somehow (sign it, post it to an immutable ledger, etc).
		\end{itemize}
	\item To generate inclusion proof for $x_i \in L$:
		\begin{itemize}
			\item Compute $C \gets \Call{plain\_tree\_chain}{L; i}$.
		\end{itemize}
	\item To verify the inclusion proof $C = \langle (b_1, y_1), \ldots, (b_\ell, y_\ell) \rangle$ for $x$:
		\begin{itemize}
			\item Check that $\Call{plain\_tree\_output}{C; x} = r$, where $r$ is the previously authenticated root hash value.
		\end{itemize}
\end{itemize}

\section{Indexed Hash Trees}

\subsection{Function $\textsc{index\_tree\_root}$}\label{sec:index-tree-root}

Computes the root value of the indexed hash tree with the given $n$ key-value pairs in its leaves.

\begin{figure}[h]
	\begin{center}
		\includegraphics[height=5cm]{pic/index-tree.png}
		\caption{Keys of the nodes of an indexed hash tree.}\label{fi:index-tree}
	\end{center}
\end{figure}

\textbf{Input}:
List $L = \langle (k_1, x_1), \ldots, (k_n, x_n) \rangle \in (\mathbb{K} \times \hashtype)^n$, the list of the key-value pairs in the $n$ leaves of the tree; $\mathbb{K}$ must be a linearly ordered type and the input pairs must be strictly sorted in this order, i.e. $k_1 < \ldots < k_n$

\textbf{Output}:
$r \in \hashtype\opt$, the value in the root of the tree

\textbf{Computation}:

\begin{algorithmic}
	\Function{index\_tree\_root}{$L$}
		\State \Assert $k_1 < \ldots < k_n$
		\If {$n = 0$} \Comment{$L = \langle \rangle$}
			\State \Return $\bot$
		\ElsIf {$n = 1$} \Comment{$L = \langle (k_1, x_1) \rangle$}
			\State \Return $H(1, k_1, x_1)$
		\Else
			\State $m \gets \lceil n/2 \rceil$ \Comment{Most balanced tree}
			\State $L_\mathsf{left} \gets \langle(k_1, x_1), \ldots, (k_m, x_m) \rangle$
			\State $L_\mathsf{right} \gets \langle (k_{m+1}, x_{m+1}), \ldots, (k_n, x_n) \rangle$
			\State \Return $H(0, k_m, \Call{index\_tree\_root}{L_\mathsf{left}}, \Call{index\_tree\_root}{L_\mathsf{right}})$
		\EndIf
	\EndFunction
\end{algorithmic}

\subsection{Function $\textsc{index\_tree\_chain}$}\label{sec:index-tree-chain}

Considers the indexed hash tree with the given $n$ key-value pairs in its leaves. If there is a leaf containing the key $k$, computes the hash chain from that leaf to the root. If there is no such leaf, computes the hash chain from the leaf where $k$ should be according to the ordering, which can be used as a proof of $k$'s absence.

\textbf{Input}:
\begin{enumerate}
	\item $L = \langle (k_1, x_1), \ldots, (k_n, x_n) \rangle \in (\mathbb{K} \times \hashtype)^n$, the list of the key-value pairs in the $n$ leaves of the tree; $\mathbb{K}$ must be a linearly ordered type and the input pairs must be strictly sorted in this order, i.e. $k_1 < \ldots < k_n$
	\item $k \in \mathbb{K}$, the key to compute the path for
\end{enumerate}

\textbf{Output}:
$C = \langle (k_1, y_1), \ldots, (k_\ell, y_\ell) \rangle \in (\mathbb{K} \times \hashtype)^\ell$, where $k_j$ are the keys in the nodes on the path from the leaf to the root and $y_j$ are the sibling hash values

\textbf{Computation}:
\begin{algorithmic}
	\Function{index\_tree\_chain}{$L; k$}
		\State \Assert $k_1 < \ldots < k_n$
		\If {$n \in \{0,1\}$} \Comment{$L = \langle \rangle$ or $L = \langle (k_1, x_1) \rangle$}
			\State \Return $L$
		\Else
			\State $m \gets \lceil n/2 \rceil$ \Comment{Must match \textsc{index\_tree\_root}}
			\State $L_\mathsf{left} \gets \langle(k_1, x_1), \ldots, (k_m, x_m) \rangle$
			\State $L_\mathsf{right} \gets \langle (k_{m+1}, x_{m+1}), \ldots, (k_n, x_n) \rangle$
			\If {$k \le k_m$}
				\State \Return $\Call{index\_tree\_chain}{L_\mathsf{left}; k} \| (k_m, \Call{index\_tree\_root}{L_\mathsf{right}})$
			\Else
				\State \Return $\Call{index\_tree\_chain}{L_\mathsf{right}; k} \| (k_m,Â \Call{index\_tree\_root}{L_\mathsf{left}})$
			\EndIf
		\EndIf
	\EndFunction
\end{algorithmic}

\subsection{Function $\textsc{index\_tree\_output}$}\label{sec:index-tree-output}

Computes the output hash of the chain $C$ on the input key $k$.

\textbf{Input}:
\begin{enumerate}
	\item $C = \langle (k_1, y_1), \ldots, (k_\ell, y_\ell) \rangle \in (\mathbb{K} \times \hashtype)^\ell$, where $k_j$ are the keys in the nodes on the path from the leaf to the root and $y_j$ are the sibling hash values
	\item $k \in \mathbb{K}$, the input key
\end{enumerate}

\textbf{Output}:
$r \in \hashtype\opt$, the value in the root of the tree

\textbf{Computation}:
\begin{algorithmic}
	\Function{index\_tree\_output}{$C; k$}
	\If {$\ell = 0$} \Comment{$C = \langle \rangle$}
		\State \Return $\bot$
	\ElsIf {$\ell = 1$} \Comment{$C = \langle (k_1, y_1) \rangle$}
		\State \Return $H(1, k_1, y_1)$
	\Else
		\If {$k \le k_\ell$}
			\State \Return $H(0, k_\ell, \Call{index\_tree\_output}{\langle (k_1, y_1), \ldots, (k_{\ell-1}, y_{\ell-1}) \rangle; k}, y_\ell)$
		\Else
			\State \Return $H(0, k_\ell, y_\ell, \Call{index\_tree\_output}{\langle (k_1, y_1), \ldots, (k_{\ell-1}, y_{\ell-1}) \rangle; k})$
		\EndIf
	\EndIf
	\EndFunction
\end{algorithmic}

\subsection{Inclusion and Exclusion Proofs}

Indexed hash trees can be used to provide and verify both inclusion and exclusion proofs. The process for this is as follows:

\begin{itemize}
	\item To commit to the contents of a list $L = \langle (k_1, x_1), \ldots, (k_n, x_n) \rangle$ (where $k_1 < \ldots < k_n$):
		\begin{itemize}
			\item Compute $r \gets \Call{index\_tree\_root}{L}$.
			\item Authenticate $r$ somehow (sign it, post it to an immutable ledger, etc).
		\end{itemize}
	\item To generate inclusion proof for $(k_i, x_i) \in L$:
		\begin{itemize}
			\item Compute $C \gets \Call{index\_tree\_chain}{L; k_i}$.
		\end{itemize}
	\item To verify the inclusion proof $C = \langle (k_1, y_1), \ldots, (k_\ell, y_\ell) \rangle$ for $(k, x)$:
		\begin{itemize}
			\item Check that $\Call{index\_tree\_output}{C; k} = r$, where $r$ is the previously authenticated root hash value.
			\item Check that $(k, x) = (k_1, y_1)$, where $(k_1, y_1)$ is the first pair in the list $C$.
		\end{itemize}
	\item To generate exclusion proof for $k \not\in \{k_1, \ldots, k_n\}$:
		\begin{itemize}
			\item Compute $C \gets \Call{index\_tree\_chain}{L; k}$.
		\end{itemize}
	\item To verify the exclusion proof $C = \langle (k_1, y_1), \ldots, (k_\ell, y_\ell) \rangle$ for $k$:
		\begin{itemize}
			\item Check that $\Call{index\_tree\_output}{C; k} = r$, where $r$ is the previously authenticated root hash value.
			\item Check that $k \ne k_1$, where $(k_1, y_1)$ is the first pair in the list $C$.
		\end{itemize}
\end{itemize}

\section{Sparse Merkle Trees}\label{app:smt}

A \emph{Sparse Merkle Tree} (SMT) is a binary Merkle tree that maps keys from a large key space to values, where most positions in the key space are empty. The \emph{path-compressed} form, documented below, retains only non-empty leaves and parent nodes with two children explicitly. The root node is an exception and may have zero, one, or two children.

\subsection{Path Compression}

In a path-compressed SMT, edges are labeled with path descriptions (bit-strings) that encode the path from child to parent.

\begin{itemize}
	\item \textbf{Leaf node hash}: $h = H(p, d)$ where:
	\begin{itemize}
		\item $p \in \bitstr$ is the path label from this node to its parent
		\item $d \in \bytes{\ast}$ is the leaf data
	\end{itemize}
	\item \textbf{Branch node hash}: $h = H(p, h_L, h_R)$ where:
	\begin{itemize}
		\item $p \in \bitstr$ is the path label from this node to its parent
		\item $h_L \in \hashtype$ is the left child hash (or $\bot$ if empty)
		\item $h_R \in \hashtype$ is the right child hash (or $\bot$ if empty)
	\end{itemize}
	\item \textbf{Root node}: Uses empty path $\epsilon$ (zero-length bit-string) in hash computation
\end{itemize}


\subsection{Function $\textsc{smt\_leaf\_hash}$}\label{sec:smt-leaf-hash}

Computes the hash of an SMT leaf node.

\textbf{Input}:
\begin{enumerate}
	\item $p \in \bitstr$ -- path segment from this leaf to its parent
	\item $d \in \hashtype$ -- leaf data (transaction hash)
\end{enumerate}

\textbf{Output}: $h \in \hashtype$ -- hash of the leaf node

\textbf{Computation}:
\begin{algorithmic}
	\Function{smt\_leaf\_hash}{$p, d$}
		\State \Return $H(p, d)$
	\EndFunction
\end{algorithmic}

\subsection{Function $\textsc{smt\_branch\_hash}$}\label{sec:smt-branch-hash}

Computes the hash of an SMT branch node.

\textbf{Input}:
\begin{enumerate}
	\item $p \in \bitstr$ -- path segment from this node to its parent
	\item $h_L \in \hashtype \cup \{\bot\}$ -- left child hash (or $\bot$ if empty)
	\item $h_R \in \hashtype \cup \{\bot\}$ -- right child hash (or $\bot$ if empty)
\end{enumerate}

\textbf{Output}: $h \in \hashtype \cup \{\bot\}$ -- hash of the branch node

\textbf{Computation}:
\begin{algorithmic}
	\Function{smt\_branch\_hash}{$p, h_L, h_R$}
		\If {$h_L = \bot \land h_R = \bot$}
			\State \Return $\bot$ \Comment{Empty subtree}
		\Else
			\State \Return $H(p, h_L, h_R)$
		\EndIf
	\EndFunction
\end{algorithmic}

Note: When hashing, $\bot$ values are encoded according to the serialization scheme (e.g., CBOR null).

\subsection{Inclusion Certificate}\label{sec:smt-inclusion-cert}

An \emph{Inclusion Certificate} for an SMT leaf with key $\mathsf{sid}$ is a sequence of pairs:
\[
C^\mathsf{inc} = \langle (p_1, d_1), (p_2, d_2), \ldots, (p_n, d_n) \rangle
\]
where:
\begin{itemize}
	\item $(p_1, d_1)$ -- the leaf's path segment and data
	\item $(p_i, d_i)$ for $i > 1$ -- path segment $p_i$ to parent and sibling hash $d_i$
	\item The concatenated path $p_1 \| p_2 \| \ldots \| p_n = \mathsf{sid}$ (full key)
\end{itemize}

\subsection{Function $\textsc{smt\_verify\_inclusion}$}\label{sec:smt-verify-inclusion}

Verifies an inclusion certificate by reconstructing the root hash.

\textbf{Input}:
\begin{enumerate}
	\item $k \in \hashtype$ -- key
	\item $v \in \hashtype$ -- value
	\item $C^\mathsf{inc} = \langle (p_1, d_1), (p_2, d_2), \ldots, (p_n, d_n) \rangle$ -- inclusion certificate
	\item $h_{\mathsf{root}} \in \hashtype$ -- expected root hash
\end{enumerate}

\textbf{Output}: \TRUE or \FALSE

\textbf{Computation}:
\begin{algorithmic}
	\Function{smt\_verify\_inclusion}{$k, v, C^\mathsf{inc}, h_{\mathsf{root}}$}
		\If {$d_1 \neq v$}
			\State \Return \FALSE \Comment{Leaf value mismatch}
		\EndIf
		\If {$p_1 \| p_2 \| \ldots \| p_n \neq k$}
			\State \Return \FALSE \Comment{Path doesn't match key}
		\EndIf
		\State $h \gets H(p_1, d_1)$ \Comment{Hash leaf node}
		\For {$i \gets 2$ to $n$}
			\State $b \gets$ rightmost bit of $p_{i-1}$
			\If {$b = 0$}
				\State $h \gets H(p_i, h, d_i)$ \Comment{Current is left child}
			\Else
				\State $h \gets H(p_i, d_i, h)$ \Comment{Current is right child}
			\EndIf
		\EndFor
		\State \Return $(h = h_{\mathsf{root}})$
	\EndFunction
\end{algorithmic}

The rightmost bit of path segment $p_{i-1}$ determines whether the current node is the left child (bit is 0) or right child (bit is 1) of its parent.

\subsection{Inclusion and Exclusion Proofs}

Sparse Merkle Trees support both inclusion and exclusion (non-inclusion) proofs using the same certificate structure.

\subsubsection{Inclusion Proof}

To prove that a key-value pair $(k, v)$ exists in an SMT:

\begin{itemize}
	\item \textbf{Generation}: Extract the path from the leaf to the root, collecting sibling hashes at each level to form $C^\mathsf{inc} = \langle (p_1, d_1), \ldots, (p_n, d_n) \rangle$
	\item \textbf{Verification}: Check that:
	\begin{enumerate}
		\item $\Call{smt\_verify\_inclusion}{k, v, C^\mathsf{inc}, h_{\mathsf{root}}} = \TRUE$
		\item The leaf data $d_1 = h_{\mathsf{tx}}$ matches the claimed value
		\item The concatenated path equals the claimed key: $p_1 \| \ldots \| p_n = \mathsf{sid}$
	\end{enumerate}
\end{itemize}

\subsubsection{Exclusion Proof (Non-Inclusion Proof)}

To prove that a key $k_q$ does NOT exist in an SMT:

\begin{itemize}
	\item \textbf{Generation}: Find the position where $k_q$ would be located if it existed. Generate a certificate $C^\mathsf{exc} = \langle (p_1, d_1), \ldots, (p_n, d_n) \rangle$ showing this position (or its prefix) has empty value.
	\item \textbf{Verification}: Check that:
	\begin{enumerate}
		\item The certificate reconstructs the correct root: \\
		      $\Call{smt\_verify\_inclusion}{k_p, d_1, C^\mathsf{exc}, h_{\mathsf{root}}} = \TRUE$ \\
		      where $k_p = p_1 \| \ldots \| p_n$ is the path from the certificate
		\item The position is empty: $d_1 = \bot$ (no leaf exists at this location)
	\end{enumerate}
\end{itemize}

The exclusion proof shows the branch where $\mathsf{sid}_q$ would be if it existed, cryptographically proving its absence from the current tree state.
